[{"categories":["技术笔记"],"content":"\rRclone支持将其他储存添加为Crypt类型的储存，用于加密存储的文件。 本文旨在简要介绍Rclone Crypt储存的加密原理，并给出Python实现的解密代码。在本文基础上，编写了rclone加密/解密代码rclone_crypt_py。 ","date":"2023-07-25","objectID":"/rclone_decrypt_by_python/:0:0","series":null,"tags":["Rclone","Python"],"title":"基于Python的Rclone Crypt储存解密","uri":"/rclone_decrypt_by_python/#"},{"categories":["技术笔记"],"content":"加密密码rclone加密有两个可设置的密码，分别记作passwd1和passwd2。其中passwd2可不设置，若不设置则使用默认值，默认值为\\xA8\\x0D\\xF4\\x3A\\x8F\\xBD\\x03\\x08\\xA7\\xCA\\xB8\\x3E\\x58\\x1F\\x86\\xB1 基于passwd1和passwd2，生成用于文件加密和文件名加密的密钥。生成密钥的算法为scrypt，scrypt算法的参数为N=16384, r=8, p=1，生成密钥的长度为80bytes。其中前32bytes用于文件加密，32-64bytes和64bytes之后的数据用于文件名加密。 通过passwd1和passwd2生成加密密钥的代码如下： from Crypto.Protocol.KDF import scrypt KEY_SIZE = 32 + 32 + 16 # scrypt生成密钥的长度 DEFAULT_SALT = b\"\\xA8\\x0D\\xF4\\x3A\\x8F\\xBD\\x03\\x08\\xA7\\xCA\\xB8\\x3E\\x58\\x1F\\x86\\xB1\" # rclone默认salt salt = passwd2 if passwd2 else DEFAULT_SALT key = scrypt(passwd, salt, KEY_SIZE, 16384, 8, 1) dataKey = key[:32] nameKey = key[32 : 64] nameTweak = key[64 :] ","date":"2023-07-25","objectID":"/rclone_decrypt_by_python/:1:0","series":null,"tags":["Rclone","Python"],"title":"基于Python的Rclone Crypt储存解密","uri":"/rclone_decrypt_by_python/#加密密码"},{"categories":["技术笔记"],"content":"文件加密加密后的文件由两部分组成，文件头和数据块。 其中文件头分为两部分： 固定rclone文件头 8 bytes，RCLONE\\x00\\x00 用于数据块解密的Nonce 24 bytes 文件头中的Nonce是加密时系统随机生成的，用于初始数据块加密。 每加密一个数据块，Nonce改变一次，以确保每个数据块的Nonce不同。在rclone的加密算法中，更改Nonce的方法为最左一位byte数字加一。实现代码为： # 单byte加1 def byte_increment(byte: int) -\u003e int: if (byte \u003e 255): raise ValueError('byte must be in range(0, 256)') return (byte + 1) if (byte \u003c 255) else 0 # nonce加1 def nonce_increment(nonce: bytes, start: int = 0) -\u003e bytes: nonce_array = bytearray(nonce) # 转为数组 # 加1操作 for i in range(start, len(nonce)): digit = nonce_array[i] newDigit = byte_increment(digit) nonce_array[i] = newDigit if newDigit \u003e= digit: break return bytes(nonce_array) #转回bytes 除了最后一个数据块外，每个数据块包含16 + 64 * 1024bytes数据，其中16bytes是用于验证的数据头，64 * 1024bytes是64 * 1024bytes原始数据加密后得到的数据。 文件块的加密算法是Nacl算法。 使用python实现的解密代码为： import nacl.secret box = nacl.secret.SecretBox(dataKey) def file_decrypt(self, input_file_path: str, output_file_path: str) -\u003e None: try: input_file = open(input_file_path, 'rb') except: raise FileNotFoundError('input file not found') try: output_file = open(output_file_path, 'wb') except: raise ValueError('failed to write output file') # 读取头 if not input_file.read(FILEMAGIC_SIZE) == b'RCLONE\\x00\\x00': # 标准头 raise ValueError('not encrypted rclone file') Nonce = input_file.read(FILENONCE_SIZE) # 读取文件块 # 16为头 # 64kb数据 input_bytes = input_file.read(BLOCKDATA_SIZE + BLOCKHEADER_SIZE) try: while (input_bytes): output_file.write(box.decrypt(input_bytes, Nonce)) Nonce = nonce_increment(Nonce) input_bytes = input_file.read(BLOCKDATA_SIZE + BLOCKHEADER_SIZE) except: raise RuntimeError('failed to decrypt file') input_file.close() output_file.close() ","date":"2023-07-25","objectID":"/rclone_decrypt_by_python/:2:0","series":null,"tags":["Rclone","Python"],"title":"基于Python的Rclone Crypt储存解密","uri":"/rclone_decrypt_by_python/#文件加密"},{"categories":["技术笔记"],"content":"文件名加密文件名有两种加密方式： standard 文件名补全为16bytes的倍数，补全算法为PKCS#7 使用EME(ECB-Mix-ECB)算法对补全后的文件名进行加密 使用生成的nameKey和nameTweak进行加密 对加密结果进行base32编码 去除结果中的= obfuscate 简单的文件名混淆，每个文件名都有一个对应的混淆距离。加密后的文件名为：\u003c混淆距离\u003e.\u003c混淆后文件名\u003e standard解密代码： from Crypto.Cipher import AES from .eme import Decrypt cipher = AES.new(nameKey, AES.MODE_ECB) def name_standard_decrypt(self, filename: str) -\u003e str: if filename == '': return '' padding_num = 8 - len(filename) % 8 filename = filename + padding_num * '=' # 添加padding filename = base64.b32hexdecode(filename.upper()) # base32解码 if len(filename) == 0: raise ValueError('too short to decrypt') if len(filename) \u003e= 2048: raise ValueError('too long to decrypt') return unpad(Decrypt(cipher, nameTweak, filename), 16, style = 'pkcs7').decode('utf-8') # EME解密 obfuscate解密代码： def name_obfuscate_decrypt(self, filename: str) -\u003e str: if filename == '': return '' pos = filename.find('.') if pos == -1: raise ValueError('not obfuscate encrypted filename') num = filename[: pos] if num == '!': return filename[pos + 1 :] try: dir_ = int(num) except: raise ValueError('not obfuscate encrypted filename') for i in self.__nameKey: dir_ = dir_ + i inQuote = False out_filename = '' for str_ in filename[pos + 1 :]: code = ord(str_) if inQuote: out_filename = out_filename + str_ elif code == ord('!'): inQuote = True elif code \u003e= ord('0') and code \u003c= ord('9'): thisdir = (dir_ % 9) + 1 newRune = ord('0') + code - '0' - thisdir if newRune \u003c ord('0'): newRune = newRune + 10 out_filename = out_filename + chr(newRune) elif (code \u003e= ord('A') and code \u003c= ord('Z')) or (code \u003e= ord('a') and code \u003c= ord('z')): thisdir = dir_ % 25 + 1 pos = code - ord('A') if pos \u003e= 26: pos = pos -6 pos = pos - thisdir if pos \u003c 0: pos = pos + 52 if pos \u003e= 26: pos = pos + 6 out_filename = out_filename + chr(ord('A') + pos) elif code \u003e= 0xa0 and code \u003c= 0xff: thisdir = (dir_ % 95) + 1 newRune = 0xa0 + code - 0xa0 - thisdir if newRune \u003c 0xa0: newRune = newRune + 96 out_filename = out_filename + chr(newRune) elif code \u003e= 0x100: thisdir = (dir_ % 127) + 1 base = code - code % 256 newRune = base + code - base - thisdir if newRune \u003c base: newRune = newRune + 256 out_filename = out_filename + chr(newRune) else: out_filename = out_filename + chr(code) return out_filename ","date":"2023-07-25","objectID":"/rclone_decrypt_by_python/:3:0","series":null,"tags":["Rclone","Python"],"title":"基于Python的Rclone Crypt储存解密","uri":"/rclone_decrypt_by_python/#文件名加密"},{"categories":["技术笔记"],"content":"\rKodi的插件可以与Kodi的GUI进行交互，提供额外的功能，可以分为repository、plugin、script、skin和resource5类。Kodi的插件可以使用Python或C++进行开发，这里介绍使用Python开发plugin类型插件的基础知识。 ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:0:0","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#"},{"categories":["技术笔记"],"content":"插件命名规则插件命名规则为：\u003caddon-type\u003e[.\u003cmedia-type\u003e].\u003cyour-plugin-name\u003e addon-type：插件类型 media-type：插件提供的媒体类型 your-plugin-name：插件名称 命名示例：plugin.video.videoscrapers ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:1:0","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#插件命名规则"},{"categories":["技术笔记"],"content":"插件文件结构Kodi中每个插件都有一个独立的文件夹，在这个文件夹包含插件代码、资源文件和插件信息文件，这个文件夹的名称应该和插件名相同。插件的文件结构一般如下： addon.py addon.xml LICENSE.txt resources/ settings.xml language/ lib/ data/ media/ fanart.jpg (can be placed anywhere in the addon directory) icon.png (can be placed anywhere in the addon directory) banner.jpg (optional - can be placed anywhere in the addon directory) clearlogo.png (optional - can be placed anywhere in the addon directory) screenshot-1.jpg (optional - can be placed anywhere in the addon directory) screenshot-2.jpg (optional - can be placed anywhere in the addon directory) screenshot-3.jpg (optional - can be placed anywhere in the addon directory) screenshot-4.jpg (optional - can be placed anywhere in the addon directory) addon.py 插件的程序入口 addon.xml 定义插件信息及依赖项等 resources 包含资源文件和代码 resources/settings.xml 包含插件的设置项 resources/lib 一般包含插件的代码 ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:2:0","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#插件文件结构"},{"categories":["技术笔记"],"content":"addon.xmladdon.xml文件示例如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?\u003e \u003caddon id=\"plugin.video.videoscrapers\" name=\"Video Scrapers\" version=\"1.2.2\" provider-name=\"Ftbom\"\u003e \u003crequires\u003e \u003cimport addon=\"xbmc.python\" version=\"3.0.0\"/\u003e \u003cimport addon=\"script.module.requests\" version=\"2.12.4\"/\u003e \u003cimport addon=\"script.module.beautifulsoup4\" version=\"4.3.2\"/\u003e \u003cimport addon=\"script.module.resolveurl\" version=\"5.0.00\"/\u003e \u003cimport addon=\"script.module.cloudscraper\" version=\"1.2.60\"/\u003e \u003c/requires\u003e \u003cextension point=\"xbmc.python.pluginsource\" library=\"addon.py\"\u003e \u003cprovides\u003evideo\u003c/provides\u003e \u003c/extension\u003e \u003cextension point=\"xbmc.addon.metadata\"\u003e \u003cplatform\u003eall\u003c/platform\u003e \u003csummary lang=\"en\"\u003eVideo Scrapers\u003c/summary\u003e \u003csummary lang=\"zh_CN\"\u003e视频聚合\u003c/summary\u003e \u003cdescription lang=\"en\"\u003eSupport scrape videos from multiple websites by simple plugins\u003c/description\u003e \u003cdescription lang=\"zh_CN\"\u003e通过插件从多个网站爬取视频\u003c/description\u003e \u003clicense\u003eGNU GPLv2\u003c/license\u003e \u003cemail\u003elz490070@gmail.com\u003c/email\u003e \u003cassets\u003e \u003cicon\u003eresources/icon.png\u003c/icon\u003e \u003cfanart\u003eresources/fanart.png\u003c/fanart\u003e \u003c/assets\u003e \u003c/extension\u003e \u003c/addon\u003e addon id：插件名 name：在Kodi中的显示名称 version：版本号 provider-name：作者名称 requires定义插件依赖项 格式：\u003cimport addon=\"xbmc.python\" version=\"3.0.0\"/\u003e extension \u003e point=\"xbmc.python.pluginsource\" library：代码入口的文件名 \u003cprovides\u003evideo\u003c/provides\u003e：插件提供的媒体类型 extension \u003e point=\"xbmc.addon.metadata\"：定义插件信息 platform：适用平台 summary：插件简介，通过lang设置对应语言 description：插件介绍，通过lang设置对应语言 license：插件授权 email：作者邮箱 assets：定义插件图标、背景图和截图 ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:2:1","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#addonxml"},{"categories":["技术笔记"],"content":"settings.xml在settings.xml中可定义插件的设置项，包括设置项类型、id、显示名称、默认值 支持的设置项类型有： 分隔符 文本输入框 数字输入 时间和日期输入框 开关 选择框 滑块 滑动转盘 文件等浏览框 可执行按钮 示例如下： \u003c?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?\u003e \u003csettings\u003e \u003ccategory label=\"Scrape Web API\"\u003e \u003csetting id=\"scrapingant\" type=\"text\" label=\"Scrapingant API\" default=\"\"/\u003e \u003csetting id=\"scrapingbee\" type=\"text\" label=\"Scrapingbee API\" default=\"\"/\u003e \u003csetting id=\"zenscrape\" type=\"text\" label=\"Zenscrape API\" default=\"\"/\u003e \u003csetting id=\"scraperapi\" type=\"text\" label=\"Scraperapi API\" default=\"\"/\u003e \u003csetting id=\"api-select\" type=\"select\" label=\"选择API\" values=\"scrapingant|scrapingbee|zenscrape|scraperapi\" /\u003e \u003c/category\u003e \u003ccategory label=\"樱花动漫\"\u003e \u003csetting id=\"yhdm\" type=\"bool\" label=\"启用\" default=\"true\"/\u003e \u003csetting id=\"yhdm-url\" type=\"text\" label=\"域名\" default=\"http://www.yinghuacd.com\"/\u003e \u003c/category\u003e \u003c/settings\u003e ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:2:2","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#settingsxml"},{"categories":["技术笔记"],"content":"程序代码编写在代码开发时，可以安装Kodistubs来辅助开发，提供代码提示。 Kodi中通过url来调用本插件和其他插件的功能，url的一般格式为：plugin_baseurl?action=list_sources\u0026xxx=xxx plugin_baseurl用于指定插件 url的params用于指定调用的函数和传递给函数的参数 ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:3:0","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#程序代码编写"},{"categories":["技术笔记"],"content":"文本格式化Kodi显示的字符支持格式化，通过在字符串的前后添加字符块来实现文本格式化 ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:3:1","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#文本格式化"},{"categories":["技术笔记"],"content":"可播放链接Kodi可以在播放链接中添加headers等信息，格式如下： http[s]://[username[:password]@]host[:port]/directory/file?a=b\u0026c=d|option1=value1\u0026option2=value2 ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:3:2","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#可播放链接"},{"categories":["技术笔记"],"content":"插件初始化在代码中通过sys来接收Kodi传递给插件的参数，参数包括三部分： __url__ 插件对应的基础url，__url__ = sys.argv[0] __handle__ 插件的handle，__handle__ = int(sys.argv[1]) __param__ 插件的params，__param__ = sys.argv[2] 插件初始化的代码一般为： import sys import xbmcplugin #插件信息 __url__ = sys.argv[0] __handle__ = int(sys.argv[1]) xbmcplugin.setContent(__handle__, 'movies') #设置插件内容的类型 ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:3:3","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#插件初始化"},{"categories":["技术笔记"],"content":"处理params在插件的入口代码中需要处理接收到的params，来执行相应的功能： from urllib.parse import parse_qsl, quote, unquote def routes(paramString): params = dict(parse_qsl(paramString[1 :])) if params: action = params['action'] if action == 'list_indexs': #列出类别 list_indexs(params['source']) elif action == 'list_videos': #列出指定类别下条目 list_videos(params['source'], params['id'], int(params['page'])) elif action == 'list_plays': #列出集 list_plays(params['source'], params['id']) elif action == 'list_sources': #列出播放链接 list_sources(params['source'], params['id'], params['title'], unquote(params['cover']), unquote(params['description'])) elif action == 'list_search_results': #列出搜索结果 if 'query' in params: list_search_results(params['query'], params['source'], int(params['page'])) #用于加载下一页 else: list_search_results(None, params['source'], int(params['page'])) #用于键盘输入搜索 elif action == 'add_favorite': add_favorite(params['data']) elif action == 'list_favorite': list_favorite() elif action == 'remove_favorite': remove_favorite(params['data']) else : mainMenu() ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:3:4","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#处理params"},{"categories":["技术笔记"],"content":"添加列表在Kodi中添加列表项的代码示例如下： import xbmcgui import xbmcplugin def mainMenu(): menuItems = [] item = xbmcgui.ListItem(label = \"[COLOR red]Test[/COLOR]\") url = f'{__url__}?action=xxx' #action url menuItems.append((url, item, True)) xbmcplugin.addDirectoryItems(__handle__, menuItems, len(menuItems)) #添加条目 xbmcplugin.addSortMethod(__handle__, xbmcplugin.SORT_METHOD_NONE) #不排序 xbmcplugin.endOfDirectory(__handle__) #添加结束 xbmcgui.ListItem(label = \"[COLOR red]Test[/COLOR]\")：列表项，通过label定义显示字符 menuItems.append((url, item, True))：添加列表项，包含列表项对应url，列表项以及是否是文件夹 xbmcplugin.addDirectoryItems(__handle__, menuItems, len(menuItems))：添加列表项列表 xbmcplugin.addSortMethod(__handle__, xbmcplugin.SORT_METHOD_NONE)：设置排序方式 xbmcplugin.endOfDirectory(__handle__)：结束 设置列表项的封面等： menuItem.setArt({'poster': cover_url}) #设置封面 menuItem.setInfo('video', {'plot': description}) #设置详情 添加列表项的右键菜单： menuItem.addContextMenuItems([(\"Test\", f'RunPlugin({plugin_url})')]) 添加可播放列表项： menuItem.setArt({'poster': cover_url}) menuItem.setInfo('video', {'genre': genre, 'plot': description}) menuItems.append((play_url, menuItem, False)) genre设置视频种类 play_url为可播放的视频链接 ","date":"2023-07-25","objectID":"/kodi_plugin_by_python/:3:5","series":null,"tags":["Kodi","Python"],"title":"基于Python的Kodi插件开发基础","uri":"/kodi_plugin_by_python/#添加列表"},{"categories":["技术笔记"],"content":"\r之前博客的评论系统用的是Valine，最近发现不能用了，原来是LeanCloud限制长时间不使用自动冻结应用。为了省事，把博客的评论系统切换到了Disqus。 Disqus提供了新评论通知的功能，但是只支持邮件通知、网页通知和Rss订阅三种方式。我并不想每次有新评论都收到邮件，Rss订阅又只支持订阅单个话题，于是就想找到通过Telegram收到新评论通知的方法。 最终通过Zapier实现了通过Telegram收到Disqus新评论通知的功能。 警告\r\rZapier免费版每个月只支持运行100次任务，即免费版每个月最多只能收到100条通知\r\r ","date":"2023-01-05","objectID":"/get-disqus-notifications-by-telegram-bot/:0:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get-disqus-notifications-by-telegram-bot/#"},{"categories":["技术笔记"],"content":"准备工作 在Telegram上向@BotFather申请机器人token； 在Telegram上通过@userinfobot获取用户id； 注册Zapier账号。 Zapier上的Disqus连接器如果设置成同时获取多种类型的新评论，在运行时会报错。需要添加两个Zap分别处理已审批和待审批的新评论。 ","date":"2023-01-05","objectID":"/get-disqus-notifications-by-telegram-bot/:1:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get-disqus-notifications-by-telegram-bot/#准备工作"},{"categories":["技术笔记"],"content":"待审批的新评论","date":"2023-01-05","objectID":"/get-disqus-notifications-by-telegram-bot/:2:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get-disqus-notifications-by-telegram-bot/#待审批的新评论"},{"categories":["技术笔记"],"content":"设置触发器首先创建新的Zap，Trigger中的App event选择Disqus连接器，然后Event选择为New Comment。如图所示： \r\r点击Continue，授权Disqus账户，授权后如图所示： \r\r继续设置trigger，include选择Unapproved Posts，Forum选择要获取新评论通知的网站，如图所示： \r\r继续向下，测试trigger，获取网站上的待审批评论的数据。若网站尚未有评论，先自行在网站上发一条评论。 匿名评论一般是待审批评论 ","date":"2023-01-05","objectID":"/get-disqus-notifications-by-telegram-bot/:2:1","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get-disqus-notifications-by-telegram-bot/#设置触发器"},{"categories":["技术笔记"],"content":"设置响应动作设置Zap的Action，App event选择Code by Zapier，Event选择Run Javascript，如图所示： \r\rSet up action中Input Data设置如下图： \r\rtg_token和tg_chatid分别填入准备工作中获取的token和id。 在Set up action的Code中填入以下代码： //Telegram机器人token const TG_API_TOKEN = inputData.tg_token; //chatid const CHAT_ID = inputData.tg_chatid; async function postData(url, data) { const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }); return response.json(); } const message = `\u003cb\u003e待审批消息\u003c/b\u003e\\n\u003cb\u003e用户名\u003c/b\u003e：${inputData.user_name}\\n\u003cb\u003e时间\u003c/b\u003e：${inputData.date}\\n\u003cb\u003e内容\u003c/b\u003e：${inputData.message}\\n\u003cb\u003e文章名\u003c/b\u003e：${inputData.article}\\n\u003cb\u003e文章链接\u003c/b\u003e：${inputData.article_url}`; console.log(\"Sending out\", message); const payload = {chat_id: CHAT_ID, text: message, disable_notification: false, parse_mode: \"HTML\"}; //Telegram API const endpoint = `https://api.telegram.org/bot${TG_API_TOKEN}/sendMessage`; //POST const resp = await postData(endpoint, payload); console.log(\"We got\", resp); //Zapier output output = resp; 继续向下，点击Test action可以进行测试，接收待审核评论的消息效果如图： \r\r","date":"2023-01-05","objectID":"/get-disqus-notifications-by-telegram-bot/:2:2","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get-disqus-notifications-by-telegram-bot/#设置响应动作"},{"categories":["技术笔记"],"content":"已审批/通过的新评论创建一个新的Zap，设置步骤与待审批的新评论设置类似，仅在某些部分有一些更改： 设置trigger时include改为选择Approved Posts； Set up action中Input Data设置如下图，admin_url设置为Disqus用户主页的链接，如：https://disqus.com/by/Ftbom/ \r Set up action的Code中填入的代码改为： const TG_API_TOKEN = inputData.tg_token; const CHAT_ID = inputData.tg_chatid; async function postData(url, data) { const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }); return response.json(); } const message = `\u003cb\u003e新评论\u003c/b\u003e\\n\u003cb\u003e用户名\u003c/b\u003e：${inputData.user_name}\\n\u003cb\u003e时间\u003c/b\u003e：${inputData.date}\\n\u003cb\u003e内容\u003c/b\u003e：${inputData.message}\\n\u003cb\u003e文章名\u003c/b\u003e：${inputData.article}\\n\u003cb\u003e文章链接\u003c/b\u003e：${inputData.article_url}`; const payload = {chat_id: CHAT_ID, text: message, disable_notification: false, parse_mode: \"HTML\"}; const endpoint = `https://api.telegram.org/bot${TG_API_TOKEN}/sendMessage`; var resp = {info: 'do nothing'}; if (inputData.isAnonymous == 'True') { resp = {info: 'is anonymous'}; } else if(inputData.profileUrl == inputData.admin_url) { resp = {info: 'is admin'}; } else { console.log(\"Sending out\", message); resp = await postData(endpoint, payload); console.log(\"We got\", resp); } output = resp; ","date":"2023-01-05","objectID":"/get-disqus-notifications-by-telegram-bot/:3:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get-disqus-notifications-by-telegram-bot/#已审批通过的新评论"},{"categories":["技术笔记"],"content":"结语经过上述步骤的设置，对于所有待审批的评论都通知；对于已审批/通过的评论，若发帖人是匿名用户或博主则不进行通知。 当网站上出现新评论后，大概延迟2-10分钟才会收到通知。 ","date":"2023-01-05","objectID":"/get-disqus-notifications-by-telegram-bot/:4:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get-disqus-notifications-by-telegram-bot/#结语"},{"categories":["技术笔记"],"content":"\rpyTelegramBotAPI版本\r\rpyTelegramBotAPI 4.8.0\r\r pyTelegramBotAPI是用于开发Telegram机器人的Python库，使用简单，上手较快。在这里记录一下pyTelegramBotAPI库的基础用法。 ","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:0:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#"},{"categories":["技术笔记"],"content":"基本部分Telegram机器人运行所需的最基本部分为： import telebot bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") bot.infinity_polling() 初始化TeleBot对象时需传入向@BotFather申请的token。 通过以下代码可以设置代理： from telebot import apihelper apihelper.proxy = {'http': 'http://127.0.0.1:108', 'https': 'http://127.0.0.1:108'} ","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:1:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#基本部分"},{"categories":["技术笔记"],"content":"绑定命令以下代码定义了机器人的/start和/help命令： import telebot bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") @bot.message_handler(commands=['start']) def send_welcome(message): bot.send_message(message.chat.id, \"Test\") @bot.message_handler(commands=['help']) def send_help(message): bot.send_message(message.chat.id, \"\u003cb\u003eTest\u003c/b\u003e\", parse_mode = \"HTML\") bot.infinity_polling() send_message函数传入的第一个参数是当前对话的id，第二个参数是发送消息的内容。通过parse_mode可以设置消息内容的格式。 上述代码的运行效果如下： \r\r","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:2:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#绑定命令"},{"categories":["技术笔记"],"content":"编辑消息编辑消息的函数为edit_message_text，使用实例如下： bot.edit_message_text('Edited', chat_id = message.chat.id, message_id = message.message_id) 第一个参数是消息的内容，第二个参数是对话的id，第三个参数是消息的id。若消息的内容与编辑之前相同，则会报错。 ","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:3:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#编辑消息"},{"categories":["技术笔记"],"content":"定义下一步通过register_next_step_handler函数可以定义下一步的操作的函数，同时可以向函数传递参数： import telebot bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") def test_next(message, test1: str, test2: str): bot.send_message(message.chat.id, f'{test1}+{test2}') @bot.message_handler(commands=['test']) def test(message): msg = bot.send_message(message.chat.id, \"Test\") bot.register_next_step_handler(msg, test_next, 'test1', 'test2') bot.infinity_polling() 下一步操作将会在接收到用户输入后进行触发。 上述代码的运行效果如下： \r\r","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:4:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#定义下一步"},{"categories":["技术笔记"],"content":"消息按键Telegram的消息按键有两种：ReplyKeyboard和InlineKeyboard ","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:5:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#消息按键"},{"categories":["技术笔记"],"content":"ReplyKeyboard import telebot from telebot.types import ReplyKeyboardMarkup bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") def test_next(message, test1: str, test2: str): bot.send_message(message.chat.id, f'{test1}+{test2}', reply_markup = ReplyKeyboardRemove()) @bot.message_handler(commands=['test']) def test(message): markup = ReplyKeyboardMarkup(resize_keyboard = True) markup.add('test1', 'test2') msg = bot.send_message(message.chat.id, \"Test\", reply_markup = markup) bot.register_next_step_handler(msg, test_next, 'test1', 'test2') bot.infinity_polling() 在ReplyKeyboardMarkup初始化时将resize_keyboard设为True，则按键会自动调节到合适的高度。 当输入/test，机器人的运行结果为： \r\r若将reply_markup的值设为ReplyKeyboardRemove，按键会在发送该消息后消失，否则按键不会消失。 运行效果为： \r\r","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:5:1","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#replykeyboard"},{"categories":["技术笔记"],"content":"InlineKeyboardInlineKeyboard是在消息的下方带有按键，且可定义按键的类型，常用的按键类型为： callback_data：按下按键则调用回调函数 url：按下按键则打开链接 pyTelegramBotAPI提供了quick_markup函数来帮助创建InlineKeyboardMarkup。 import telebot from telebot.util import quick_markup bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") @bot.message_handler(commands=['test']) def test(message): button = {\"test1\": {\"callback_data\": \"test\"}, \"test2\": {\"url\": \"google.com\"}} bot.send_message(message.chat.id, \"Test\", reply_markup = quick_markup(button, row_width = 2)) @bot.callback_query_handler(func=lambda call: True) def refresh(call): if (call.data == \"test\"): bot.send_message(call.message.chat.id, \"Test Callback\") bot.answer_callback_query(call.id) bot.infinity_polling() quick_markup的row_width参数定义了同一行的最大按钮数量。 上述代码定义的InlineKeyboard样式为： \r\r通过@bot.callback_query_handler函数修饰符对callback_data处理，call.data对应callback_data。再按下按键后，按键上会出现进度标志，通过调用answer_callback_query可以消去进度标志。 上述代码，按下test1按钮后，结果为： \r\r","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:5:2","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#inlinekeyboard"},{"categories":["技术笔记"],"content":"文件处理Telegram消息主要的文件类型为：animation、audio、document、photo、sticker、video、video_note、voice，这些文件类型都有对应的file_id，通过id可以获取文件的下载链接。 获取id: file_id = message.document.file_id 获取下载链接： download_url = bot.get_file_url(file_id) 若收到的消息不是此种文件类型，则message.\u003ctype\u003e返回None 在这些文件类型中，photo类型有所不同，其返回值是一个数组，数组的每个元素对应不同的分辨率。 ","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:6:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#文件处理"},{"categories":["技术笔记"],"content":"结语这篇文章中记录的是pyTelegramBotAPI的基本用法，也是我在项目mypybot中用到的主要API内容。 ","date":"2023-01-04","objectID":"/basic-of-pytelegrambotapi/:7:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic-of-pytelegrambotapi/#结语"},{"categories":["技术笔记"],"content":"\rLANraragi提供了丰富的插件和脚本，借助插件能够以多种途径获取漫画的信息，但是这些插件并没有完全满足我的需求。 于是有了这篇文章，记录我的LANraragi插件编写过程。 ","date":"2023-01-03","objectID":"/lanraragi-plugins/:0:0","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi-plugins/#"},{"categories":["技术笔记"],"content":"需求在LANraragi中，漫画的信息被记录成tags和categories，即标签和种类。 我的需求是能从文件的目录结构提取出漫画的标签和种类，文件的结构如下： category1 --tag1 --mangafile1 --mangafile2 --tag2 --mangafile3 category2 --tag3 --mangafile4 ","date":"2023-01-03","objectID":"/lanraragi-plugins/:1:0","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi-plugins/#需求"},{"categories":["技术笔记"],"content":"折腾结果LANraragi中并不存在实现上述功能的插件，于是我就参照已有的插件，实现了这些功能。 最终完成了一个脚本和一个插件： TagFolder.pm(插件) 将文件所属的文件夹名作为漫画的tag FolderToCat.pm(脚本) 将文件所属的文件夹名作为漫画的category，可选是否使用顶层文件夹 ","date":"2023-01-03","objectID":"/lanraragi-plugins/:2:0","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi-plugins/#折腾结果"},{"categories":["技术笔记"],"content":"TagFolder.pm 参照Filename Parsing v.1.0 by Difegue \r\r使用说明： Plugin Settings设置tag的类别，如图中所示则最终tag效果为artist: tagname 开启Run Automatically则自动对新添加的漫画运行插件 下载地址：TagFolder.pm 文件内容： package LANraragi::Plugin::Metadata::TagFolder; use strict; use warnings; #Plugins can freely use all Perl packages already installed on the system #Try however to restrain yourself to the ones already installed for LRR (see tools/cpanfile) to avoid extra installations by the end-user. use File::Basename; #You can also use the LRR Internal API when fitting. use LANraragi::Model::Plugins; use LANraragi::Utils::Database qw(redis_encode redis_decode); use LANraragi::Utils::Logging qw(get_logger); #Meta-information about your plugin. sub plugin_info { return ( #Standard metadata name =\u003e \"Use foldername as tag\", type =\u003e \"metadata\", namespace =\u003e \"tagfolder\", author =\u003e \"Ftbom\", version =\u003e \"1.0\", description =\u003e \"Generate the tag from the folder's name.\", icon =\u003e \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAL1JREFUOI1jZMABpNbH/sclx8DAwPAscDEjNnEMQUIGETIYhUOqYdgMhTPINQzdUEZqGIZsKBM1DEIGTOiuexqwCKdidDl0vtT62P9kuZCJEWuKYWBgYGBgRHbh04BFDNIb4jAUbbSrZTARUkURg6lD10OUC/0PNaMYgs1Skgwk1jCSDCQWoBg46dYmhite0+D8pwGLCMY6uotRDOy8toZBkI2HIhcO/pxCm8KBUkOxFl/kGoq3gCXFYFxVAACeoU/8xSNybwAAAABJRU5ErkJggg==\", parameters =\u003e [ { type =\u003e \"string\", desc =\u003e \"The category of tag\" } ] #plugin设置 ); } #Mandatory function to be implemented by your plugin sub get_tags { shift; my $lrr_info = shift; # Global info hash my ($category) = @_; # Plugin parameters my $logger = get_logger( \"tagfolder\", \"plugins\" ); my $file = $lrr_info-\u003e{file_path}; #完整文件地址 my $tagstring; # lrr_info's file_path is taken straight from the filesystem, which might not be proper UTF-8. # Run a decode to make sure we can derive tags with the proper encoding. $file = redis_decode($file); # Get the filename from the file_path info field my ( $filename, $filepath, $suffix ) = fileparse( $file, qr/\\.[^.]*/ ); $_ = \"$filepath\"; #获取文件地址 if (/\\/([^\\/]+)\\/$/) { $tagstring=\"$category:$1\"; #上级目录作tag名 } $logger-\u003edebug( \"Sending the following tags to LRR: \" . $tagstring ); return ( tags =\u003e $tagstring ); } 1; ","date":"2023-01-03","objectID":"/lanraragi-plugins/:2:1","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi-plugins/#tagfolderpm"},{"categories":["技术笔记"],"content":"FolderToCat.pm 参照Subfolders to Categories v.1.0 by Difegue \r\r使用说明： 点击Trigger Script运行脚本 Plugin Settings可进行设置：是否删除已存在的类别和是否使用顶层文件夹 下载地址：FolderToCat.pm 文件内容： package LANraragi::Plugin::Scripts::FolderToCat; use strict; use warnings; use File::Find; use File::Basename; use Data::Dumper; use LANraragi::Utils::Logging qw(get_logger); use LANraragi::Utils::Generic qw(is_archive); use LANraragi::Utils::Database qw(compute_id); use LANraragi::Model::Category; #Meta-information about your plugin. sub plugin_info { return ( #Standard metadata name =\u003e \"Subfolders to Categories\", type =\u003e \"script\", namespace =\u003e \"fldr2cat\", author =\u003e \"Difegue\", version =\u003e \"1.0\", icon =\u003e \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAuJJREFUOI3FlE1sVFUUx3/nvVdaSqd0sAmElDYopOWjsKiEnYkLowU2uMGw0ajBhS5oqAtwo3FTaIQNCz7CBldEE01M+AglJMACUyBQrI6iQ2groNNxpjPz5n3MnXddvOnrfACNK09yk/fuved3//933j3wf8Thw6O6q6tHd3X16FOnTusX7ZW7I7H0kuUrV6hCtmHxt7UnOXHiDInEJAAzM49kscMtw2xesWHfKOTGASNa+GnmHfYP7gSgr28TY2PnF4UBWAD88Tlk7kFVyuDbX0ew43vzU/6bnc+12vnqx4OrX//i4gIQXS2uJkZGvqRXD3Q/V9LKXdjmSxcmjq7ahi6vtRazMKAHGua8oolbsHDyFk7iF4r/3IOyGl9QKI1u+vo2kUhMsmZ3T8Pa5c+E5vYYzbFWWkQTW23R+XKc+9/+eKUB+MbBHZWqhpW9MGSjtdDes57OzRtZ2hFD4tshcEAVkHIeVIapse8wDPNQxbKBDuDhxHKODd5myZ44698dBTQgUbEkex0CFzJXIfDC58CDwCP3Z1ZtPpAaD4FWnJIv2Nkm+j85AroE/jRoHwI/SgoBbt27h+54DS3je0VEh7VtimOnm2mKxRcguhpUDXvGUDb9bd3fh14rCtNPWuh9/6s6RfWq6mEetG0le/cb5KPbpajKActwChaIVNR5ddAqeLkCmt9TLjCbzEVFtQDstENTW0c4M58cJbiNsPmxtBs7eQ03p87VANP3J+n94CjiPKj76N4z7M4f6IPKk35YAFMORUCzpRU3/VdoV82BytUm+jMQlEArlBJmEyncORdnroTypxCRt7YMp5IRUBVzv/cPnV0n+VshyH8MgYuycyjHJjPt4GbyONki5VIAItfQnBeTG62YD1458DTF8EJXscSw1lEu4s0m8TJ/k/o5iZuZIygHlb+ZHwzkUoC+2T+cuiNSd08/re1qMjFa25YM5D0xjVtGe8fUhg9/zfMf41+ZdKPYI8TqHgAAAABJRU5ErkJggg==\", description =\u003e \"Scan your Content Folder and automatically create Static Categories for each subfolder.\u003cbr\u003eThis Script will create a category for each subfolder with archives as direct children.\", parameters =\u003e [ { type =\u003e \"bool\", desc =\u003e \"Delete all your static categories before creating the ones matching your subfolders\" }, { type =\u003e \"bool\", desc =\u003e \"Create categories by the top level subfolder\" }] ); } # Mandatory function to be implemented by your script sub run_script { shift; my $lrr_info = shift; my ($delete_old_cats, $by_top_folder) = @_; my $logger = get_logger( \"Folder2Category\", \"plugins\" ); my $userdir = LANraragi::Model::Config-\u003eget_userdir; my %subfolders; my @created_categories; my $dirname; if ($delete_old_cats) { $logger-\u003einfo(\"Deleting all Static Categories before folder walking as instructed.\"); my @categories = LANraragi::Model::Category-\u003eget_static_category_list; for my $category (@categories) { my $cat_id = %{$category}{\"id\"}; $logger-\u003edebug(\"Deleting '$cat_id'\"); LANraragi::Model::Category::delete_category($cat_id); } } # Walk through content folder and find all subfolders with files in them find( { wanted =\u003e sub { return if $File::Find::dir eq $userdir; # Direct children of the content dir are excluded if (not($by_top_folder)) { $dirname = basename($File::Find::dir); } if ( is_archive($_) ) { unless ( exists( $subfolders{$dirname} ) ) { $subfolders{$dirname} = []; # Create array in hash for this folder } push @{ $subfolders{$dirname} }, $_; } elsif ($by_top_folder) { $dirname = basename($File::Find::dir); } }, no_chdir =\u003e 1, follow_fast =\u003e 1 }, $userdir ); $logger-\u003edebug( \"Find routine results: \" . Dumper %subfolders ); # For each subfolder with file, create a category bearing its name and containing all its files for my $folder ( keys %subfolders ) { my $catID = LANraragi::Model::Category::create_category( $folder, \"\", 0, \"\" ); push @created_categories, $catID; for my $file ( @{ $subfolders{$folder} } ) { eval { my $id = compute_id($file) || next; LANraragi::Model::Category::add_to_category( $catID, $id ); }; } } return ( created_categories =\u003e \\@created_categories ); } 1; ","date":"2023-01-03","objectID":"/lanraragi-plugins/:2:2","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi-plugins/#foldertocatpm"},{"categories":["技术笔记"],"content":"代码浅析简单分析一下这两个插件的代码，我并没有系统地学习过Perl语言，分析过程可能存在错误。 plugin_info函数返回插件的基本信息；TagFolder是元数据插件，主体内容是get_tags函数；FolderToCat是脚本，主体内容是run_script函数。 plugin_info函数的parameters返回值定义了插件的设置项，例如： TagFolder定义插件的设置项是string类型，获取输入字符；FolderToCat定义插件的设置项是bool类型，获取开关的状态。 在主体函数中可以通过@_获取插件的设置值。 ","date":"2023-01-03","objectID":"/lanraragi-plugins/:3:0","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi-plugins/#代码浅析"},{"categories":["技术笔记"],"content":"TagFolder.pm分析TagFolder参照Filename Parsing，对其中关键代码的运行过程进行分析。 首先获取全局信息和插件设置： my $lrr_info = shift; #全局信息 my ($category) = @_; #插件设置 全局信息中包括文件路径： my $file = $lrr_info-\u003e{file_path}; 然后从文件路径中分离出文件名和文件所在文件夹路径，我们需要的是文件夹路径： my ( $filename, $filepath, $suffix ) = fileparse( $file, qr/\\.[^.]*/ ); 从文件夹路径中获取文件夹名，得到tag字符串： $_ = \"$filepath\"; #$_是默认的参数变量 if (/\\/([^\\/]+)\\/$/) { $tagstring=\"$category:$1\"; #$1获取正则表达式匹配的第一项 } 最后输出tag信息： return ( tags =\u003e $tagstring ); ","date":"2023-01-03","objectID":"/lanraragi-plugins/:3:1","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi-plugins/#tagfolderpm分析"},{"categories":["技术笔记"],"content":"FolderToCat.pm分析FolderToCat.pm仅在Subfolders to Categories的基础上做了一些小改动，改动部分主要为： return if $File::Find::dir eq $userdir; # Direct children of the content dir are excluded if (not($by_top_folder)) { $dirname = basename($File::Find::dir); } if ( is_archive($_) ) { unless ( exists( $subfolders{$dirname} ) ) { $subfolders{$dirname} = []; # Create array in hash for this folder } push @{ $subfolders{$dirname} }, $_; } elsif ($by_top_folder) { $dirname = basename($File::Find::dir); } 这里假设文件目录结构为，且假设插件设置使用顶层文件夹： category1 --tag1 --mangafile1 --mangafile2 --tag2 --mangafile3 category2 --tag3 --mangafile4 首先排除漫画目录的直接子文件夹，即categroy1、categroy2等文件夹： return if $File::Find::dir eq $userdir; 对于其他的文件和文件夹，如果是文件夹，即tag1、tag2等文件夹，则将其父目录的名称赋值给dirname。即将categroy1、categroy2等赋值给dirname: elsif ($by_top_folder) { $dirname = basename($File::Find::dir); } 如果是文件，若其路径中存在dirname，则将其添加到对应数组。例如：mangafile1、mangafile2、mangafile3文件被添加到category1对应的数组： if ( is_archive($_) ) { unless ( exists( $subfolders{$dirname} ) ) { $subfolders{$dirname} = []; # Create array in hash for this folder } push @{ $subfolders{$dirname} }, $_; } 最后通过这些数组来创建类别，并将对应漫画添加到类别中： for my $folder ( keys %subfolders ) { my $catID = LANraragi::Model::Category::create_category( $folder, \"\", 0, \"\" ); push @created_categories, $catID; for my $file ( @{ $subfolders{$folder} } ) { eval { my $id = compute_id($file) || next; LANraragi::Model::Category::add_to_category( $catID, $id ); }; } } ","date":"2023-01-03","objectID":"/lanraragi-plugins/:3:2","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi-plugins/#foldertocatpm分析"},{"categories":["技术笔记"],"content":"\rLANraragi是开源的漫画管理服务器，开发者提供了多种安装方式供选择。本文介绍如何在Termux中安装LANraragi，实现对Android手机内的漫画进行管理。 ","date":"2023-01-03","objectID":"/lanraragi-in-termux/:0:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi-in-termux/#"},{"categories":["技术笔记"],"content":"安装Termux及Ubuntu发行版Termux是Android系统上的一个高级终端模拟器，可以运行很多Linux系统的软件，还可通过proot安装各种Linux系统发行版。推荐通过Github安装Termux软件。 警告\r\r第一次打开Termux若初始化失败，请使用代理\r\r 安装完成后，首先使Termux获取储存权限： termux-setup-storage 安装proot-distro： pkg install proot-distro 然后安装Ubuntu proot-distro install ubuntu 安装完成后，通过如下命令可进入Ubuntu proot-distro login ubuntu ","date":"2023-01-03","objectID":"/lanraragi-in-termux/:1:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi-in-termux/#安装termux及ubuntu发行版"},{"categories":["技术笔记"],"content":"安装LANraragi采用源码安装的方式安装LANraragi。 首先，进入Ubuntu并更新软件源： proot-distro login ubuntu apt update 首先安装LANraragi所需的依赖项： apt install git curl build-essential make gnupg pkg-config cpanminus redis-server libarchive-dev imagemagick webp libssl-dev zlib1g-dev perlmagick ghostscript 然后安装npm和nodejs： curl -sL install-node.vercel.app/lts | bash 安装redis： apt install redis 克隆Git仓库： git clone -b master http://github.com/Difegue/LANraragi /home/koyomi/lanraragi 打开目录并进行编译安装： cd /home/koyomi/lanraragi \u0026\u0026 npm run lanraragi-installer install-full 编译需要30-60分钟。 若需要对LANraragi进行更新： git clone -b master http://github.com/Difegue/LANraragi lanraragi cp -fr lanraragi /home/koyomi/ npm run lanraragi-installer install-full ","date":"2023-01-03","objectID":"/lanraragi-in-termux/:2:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi-in-termux/#安装lanraragi"},{"categories":["技术笔记"],"content":"运行LANraragi通过以下命令运行LANraragi： redis-server /etc/redis/redis.conf cd /home/koyomi/lanraragi \u0026\u0026 npm start ","date":"2023-01-03","objectID":"/lanraragi-in-termux/:3:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi-in-termux/#运行lanraragi"},{"categories":["技术笔记"],"content":"设置档案位置若已通过以下命令使Termux获取储存权限： termux-setup-storage 则在Ubuntu的/sdcard目录下可以看到Android系统的文件，在LANraragi的设置中设置成对应的漫画目录即可。 ","date":"2023-01-03","objectID":"/lanraragi-in-termux/:4:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi-in-termux/#设置档案位置"},{"categories":["技术笔记"],"content":"\rJulia是一种高级通用动态编程语言，可以用于数值分析和科学计算等。 Julia语言没有内建的作图能力，作图需要通过安装扩展包来实现，常用的作图包有Gadfly、Plots和PyPlot。 本文介绍如何在Julia脚本文件中使用Plots进行绘图并正常显示绘图结果。 Julia和Plots版本\r\rJulia v1.7.2 Plots v1.25.11 \r\r ","date":"2022-02-25","objectID":"/julia-plot-in-file/:0:0","series":null,"tags":["Julia"],"title":"Julia脚本文件中使用Plots绘图","uri":"/julia-plot-in-file/#"},{"categories":["技术笔记"],"content":"在REPL中运行脚本文件在REPL中，Julia会对每个变量自动调用display函数进行显示。在REPL中直接使用plot函数可以正常显示绘图的结果。 本文的主要目的是使用脚本文件进行绘图，在REPL中运行脚本文件的命令为： include(\"path/to/script.jl\") ","date":"2022-02-25","objectID":"/julia-plot-in-file/:1:0","series":null,"tags":["Julia"],"title":"Julia脚本文件中使用Plots绘图","uri":"/julia-plot-in-file/#在repl中运行脚本文件"},{"categories":["技术笔记"],"content":"使用julia path/to/script.jl运行脚本文件如果不在REPL中运行脚本文件时，Julia不会自动调用display函数。 为了显示绘图结果，需要在代码中调用display函数。 但是，使用julia path/to/script.jl运行脚本文件时，程序会在文件中所有语句执行完毕后自动退出，这样就看不到绘图结果。 为了防止Julia执行完所有语句后退出，可以在脚本文件的末尾使用readline函数。 这种运行方式下需将代码做如下更改： plot(x, y) 改为 display(plot(x, y)) ... readline() 然后终端运行julia path/to/script.jl即可得到绘图结果。 ","date":"2022-02-25","objectID":"/julia-plot-in-file/:2:0","series":null,"tags":["Julia"],"title":"Julia脚本文件中使用Plots绘图","uri":"/julia-plot-in-file/#使用julia-pathtoscriptjl运行脚本文件"},{"categories":["技术笔记"],"content":"使用VScode插件Julia运行脚本文件使用Julia插件运行代码时，会自动将绘图结果显示在一个新的标签栏中，于是直接使用plot函数就可以得到绘图结果。 需要注意的是：在VScode中不可使用Code Runner插件来运行脚本文件，而要使用Julia插件来运行脚本文件。 ","date":"2022-02-25","objectID":"/julia-plot-in-file/:3:0","series":null,"tags":["Julia"],"title":"Julia脚本文件中使用Plots绘图","uri":"/julia-plot-in-file/#使用vscode插件julia运行脚本文件"}]