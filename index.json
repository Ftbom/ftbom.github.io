[{"categories":["技术笔记"],"content":"\r之前博客的评论系统用的是Valine，最近发现不能用了，原来是LeanCloud限制长时间不使用自动冻结应用。为了省事，把博客的评论系统切换到了Disqus。 Disqus提供了新评论通知的功能，但是只支持邮件通知、网页通知和Rss订阅三种方式。我并不想每次有新评论都收到邮件，Rss订阅又只支持订阅单个话题，于是就想找到通过Telegram收到新评论通知的方法。 最终通过Zapier实现了通过Telegram收到Disqus新评论通知的功能。 警告\r\rZapier免费版每个月只支持运行100次任务，即免费版每个月最多只能收到100条通知\r\r ","date":"2023-01-05","objectID":"/get_disqus_notifications_by_telegram_bot/:0:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get_disqus_notifications_by_telegram_bot/#"},{"categories":["技术笔记"],"content":"准备工作 在Telegram上向@BotFather申请机器人token； 在Telegram上通过@userinfobot获取用户id； 注册Zapier账号。 Zapier上的Disqus连接器如果设置成同时获取多种类型的新评论，在运行时会报错。需要添加两个Zap分别处理已审批和待审批的新评论。 ","date":"2023-01-05","objectID":"/get_disqus_notifications_by_telegram_bot/:1:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get_disqus_notifications_by_telegram_bot/#准备工作"},{"categories":["技术笔记"],"content":"待审批的新评论","date":"2023-01-05","objectID":"/get_disqus_notifications_by_telegram_bot/:2:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get_disqus_notifications_by_telegram_bot/#待审批的新评论"},{"categories":["技术笔记"],"content":"设置触发器首先创建新的Zap，Trigger中的App event选择Disqus连接器，然后Event选择为New Comment。如图所示： \r\r点击Continue，授权Disqus账户，授权后如图所示： \r\r继续设置trigger，include选择Unapproved Posts，Forum选择要获取新评论通知的网站，如图所示： \r\r继续向下，测试trigger，获取网站上的待审批评论的数据。若网站尚未有评论，先自行在网站上发一条评论。 匿名评论一般是待审批评论 ","date":"2023-01-05","objectID":"/get_disqus_notifications_by_telegram_bot/:2:1","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get_disqus_notifications_by_telegram_bot/#设置触发器"},{"categories":["技术笔记"],"content":"设置响应动作设置Zap的Action，App event选择Code by Zapier，Event选择Run Javascript，如图所示： \r\rSet up action中Input Data设置如下图： \r\rtg_token和tg_chatid分别填入准备工作中获取的token和id。 在Set up action的Code中填入以下代码： //Telegram机器人token const TG_API_TOKEN = inputData.tg_token; //chatid const CHAT_ID = inputData.tg_chatid; async function postData(url, data) { const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }); return response.json(); } const message = `\u003cb\u003e待审批消息\u003c/b\u003e\\n\u003cb\u003e用户名\u003c/b\u003e：${inputData.user_name}\\n\u003cb\u003e时间\u003c/b\u003e：${inputData.date}\\n\u003cb\u003e内容\u003c/b\u003e：${inputData.message}\\n\u003cb\u003e文章名\u003c/b\u003e：${inputData.article}\\n\u003cb\u003e文章链接\u003c/b\u003e：${inputData.article_url}`; console.log(\"Sending out\", message); const payload = {chat_id: CHAT_ID, text: message, disable_notification: false, parse_mode: \"HTML\"}; //Telegram API const endpoint = `https://api.telegram.org/bot${TG_API_TOKEN}/sendMessage`; //POST const resp = await postData(endpoint, payload); console.log(\"We got\", resp); //Zapier output output = resp; 继续向下，点击Test action可以进行测试，接收待审核评论的消息效果如图： \r\r","date":"2023-01-05","objectID":"/get_disqus_notifications_by_telegram_bot/:2:2","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get_disqus_notifications_by_telegram_bot/#设置响应动作"},{"categories":["技术笔记"],"content":"已审批/通过的新评论创建一个新的Zap，设置步骤与待审批的新评论设置类似，仅在某些部分有一些更改： 设置trigger时include改为选择Approved Posts； Set up action中Input Data设置如下图，admin_url设置为Disqus用户主页的链接，如：https://disqus.com/by/Ftbom/ \r Set up action的Code中填入的代码改为： const TG_API_TOKEN = inputData.tg_token; const CHAT_ID = inputData.tg_chatid; async function postData(url, data) { const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }); return response.json(); } const message = `\u003cb\u003e新评论\u003c/b\u003e\\n\u003cb\u003e用户名\u003c/b\u003e：${inputData.user_name}\\n\u003cb\u003e时间\u003c/b\u003e：${inputData.date}\\n\u003cb\u003e内容\u003c/b\u003e：${inputData.message}\\n\u003cb\u003e文章名\u003c/b\u003e：${inputData.article}\\n\u003cb\u003e文章链接\u003c/b\u003e：${inputData.article_url}`; const payload = {chat_id: CHAT_ID, text: message, disable_notification: false, parse_mode: \"HTML\"}; const endpoint = `https://api.telegram.org/bot${TG_API_TOKEN}/sendMessage`; var resp = {info: 'do nothing'}; if (inputData.isAnonymous == 'True') { resp = {info: 'is anonymous'}; } else if(inputData.profileUrl == inputData.admin_url) { resp = {info: 'is admin'}; } else { console.log(\"Sending out\", message); resp = await postData(endpoint, payload); console.log(\"We got\", resp); } output = resp; ","date":"2023-01-05","objectID":"/get_disqus_notifications_by_telegram_bot/:3:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get_disqus_notifications_by_telegram_bot/#已审批通过的新评论"},{"categories":["技术笔记"],"content":"结语经过上述步骤的设置，对于所有待审批的评论都通知；对于已审批/通过的评论，若发帖人是匿名用户或博主则不进行通知。 当网站上出现新评论后，大概延迟2-10分钟才会收到通知。 ","date":"2023-01-05","objectID":"/get_disqus_notifications_by_telegram_bot/:4:0","series":null,"tags":["Disqus","Telegram","Zapier"],"title":"借助Zapier将Disqus通知推送到Telegram机器人","uri":"/get_disqus_notifications_by_telegram_bot/#结语"},{"categories":["技术笔记"],"content":"\rpyTelegramBotAPI版本\r\rpyTelegramBotAPI 4.8.0\r\r pyTelegramBotAPI是用于开发Telegram机器人的Python库，使用简单，上手较快。在这里记录一下pyTelegramBotAPI库的基础用法。 ","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:0:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#"},{"categories":["技术笔记"],"content":"基本部分Telegram机器人运行所需的最基本部分为： import telebot bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") bot.infinity_polling() 初始化TeleBot对象时需传入向@BotFather申请的token。 通过以下代码可以设置代理： from telebot import apihelper apihelper.proxy = {'http': 'http://127.0.0.1:108', 'https': 'http://127.0.0.1:108'} ","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:1:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#基本部分"},{"categories":["技术笔记"],"content":"绑定命令以下代码定义了机器人的/start和/help命令： import telebot bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") @bot.message_handler(commands=['start']) def send_welcome(message): bot.send_message(message.chat.id, \"Test\") @bot.message_handler(commands=['help']) def send_help(message): bot.send_message(message.chat.id, \"\u003cb\u003eTest\u003c/b\u003e\", parse_mode = \"HTML\") bot.infinity_polling() send_message函数传入的第一个参数是当前对话的id，第二个参数是发送消息的内容。通过parse_mode可以设置消息内容的格式。 上述代码的运行效果如下： \r\r","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:2:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#绑定命令"},{"categories":["技术笔记"],"content":"编辑消息编辑消息的函数为edit_message_text，使用实例如下： bot.edit_message_text('Edited', chat_id = message.chat.id, message_id = message.message_id) 第一个参数是消息的内容，第二个参数是对话的id，第三个参数是消息的id。若消息的内容与编辑之前相同，则会报错。 ","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:3:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#编辑消息"},{"categories":["技术笔记"],"content":"定义下一步通过register_next_step_handler函数可以定义下一步的操作的函数，同时可以向函数传递参数： import telebot bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") def test_next(message, test1: str, test2: str): bot.send_message(message.chat.id, f'{test1}+{test2}') @bot.message_handler(commands=['test']) def test(message): msg = bot.send_message(message.chat.id, \"Test\") bot.register_next_step_handler(msg, test_next, 'test1', 'test2') bot.infinity_polling() 下一步操作将会在接收到用户输入后进行触发。 上述代码的运行效果如下： \r\r","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:4:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#定义下一步"},{"categories":["技术笔记"],"content":"消息按键Telegram的消息按键有两种：ReplyKeyboard和InlineKeyboard ","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:5:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#消息按键"},{"categories":["技术笔记"],"content":"ReplyKeyboard import telebot from telebot.types import ReplyKeyboardMarkup bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") def test_next(message, test1: str, test2: str): bot.send_message(message.chat.id, f'{test1}+{test2}', reply_markup = ReplyKeyboardRemove()) @bot.message_handler(commands=['test']) def test(message): markup = ReplyKeyboardMarkup(resize_keyboard = True) markup.add('test1', 'test2') msg = bot.send_message(message.chat.id, \"Test\", reply_markup = markup) bot.register_next_step_handler(msg, test_next, 'test1', 'test2') bot.infinity_polling() 在ReplyKeyboardMarkup初始化时将resize_keyboard设为True，则按键会自动调节到合适的高度。 当输入/test，机器人的运行结果为： \r\r若将reply_markup的值设为ReplyKeyboardRemove，按键会在发送该消息后消失，否则按键不会消失。 运行效果为： \r\r","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:5:1","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#replykeyboard"},{"categories":["技术笔记"],"content":"InlineKeyboardInlineKeyboard是在消息的下方带有按键，且可定义按键的类型，常用的按键类型为： callback_data：按下按键则调用回调函数 url：按下按键则打开链接 pyTelegramBotAPI提供了quick_markup函数来帮助创建InlineKeyboardMarkup。 import telebot from telebot.util import quick_markup bot = telebot.TeleBot(\"YOUR_BOT_TOKEN\") @bot.message_handler(commands=['test']) def test(message): button = {\"test1\": {\"callback_data\": \"test\"}, \"test2\": {\"url\": \"google.com\"}} bot.send_message(message.chat.id, \"Test\", reply_markup = quick_markup(button, row_width = 2)) @bot.callback_query_handler(func=lambda call: True) def refresh(call): if (call.data == \"test\"): bot.send_message(call.message.chat.id, \"Test Callback\") bot.answer_callback_query(call.id) bot.infinity_polling() quick_markup的row_width参数定义了同一行的最大按钮数量。 上述代码定义的InlineKeyboard样式为： \r\r通过@bot.callback_query_handler函数修饰符对callback_data处理，call.data对应callback_data。再按下按键后，按键上会出现进度标志，通过调用answer_callback_query可以消去进度标志。 上述代码，按下test1按钮后，结果为： \r\r","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:5:2","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#inlinekeyboard"},{"categories":["技术笔记"],"content":"文件处理Telegram消息主要的文件类型为：animation、audio、document、photo、sticker、video、video_note、voice，这些文件类型都有对应的file_id，通过id可以获取文件的下载链接。 获取id: file_id = message.document.file_id 获取下载链接： download_url = bot.get_file_url(file_id) 若收到的消息不是此种文件类型，则message.\u003ctype\u003e返回None 在这些文件类型中，photo类型有所不同，其返回值是一个数组，数组的每个元素对应不同的分辨率。 ","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:6:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#文件处理"},{"categories":["技术笔记"],"content":"结语这篇文章中记录的是pyTelegramBotAPI的基本用法，也是我在项目mypybot中用到的主要API内容。 ","date":"2023-01-04","objectID":"/basic_of_pytelegrambotapi/:7:0","series":null,"tags":["Python","Telegram"],"title":"pyTelegramBotAPI基础","uri":"/basic_of_pytelegrambotapi/#结语"},{"categories":["技术笔记"],"content":"\rLANraragi提供了丰富的插件和脚本，借助插件能够以多种途径获取漫画的信息，但是这些插件并没有完全满足我的需求。 于是有了这篇文章，记录我的LANraragi插件编写过程。 ","date":"2023-01-03","objectID":"/lanraragi_plugins/:0:0","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi_plugins/#"},{"categories":["技术笔记"],"content":"需求在LANraragi中，漫画的信息被记录成tags和categories，即标签和种类。 我的需求是能从文件的目录结构提取出漫画的标签和种类，文件的结构如下： category1 --tag1 --mangafile1 --mangafile2 --tag2 --mangafile3 category2 --tag3 --mangafile4 ","date":"2023-01-03","objectID":"/lanraragi_plugins/:1:0","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi_plugins/#需求"},{"categories":["技术笔记"],"content":"折腾结果LANraragi中并不存在实现上述功能的插件，于是我就参照已有的插件，实现了这些功能。 最终完成了一个脚本和一个插件： TagFolder.pm(插件) 将文件所属的文件夹名作为漫画的tag TopfolderCat.pm(脚本) 将文件所属的顶层文件夹名作为漫画的category ","date":"2023-01-03","objectID":"/lanraragi_plugins/:2:0","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi_plugins/#折腾结果"},{"categories":["技术笔记"],"content":"TagFolder.pm 参照Filename Parsing v.1.0 by Difegue \r\r使用说明： Plugin Settings设置tag的类别，如图中所示则最终tag效果为artist: tagname 开启Run Automatically则自动对新添加的漫画运行插件 文件内容： package LANraragi::Plugin::Metadata::TagFolder; use strict; use warnings; #Plugins can freely use all Perl packages already installed on the system #Try however to restrain yourself to the ones already installed for LRR (see tools/cpanfile) to avoid extra installations by the end-user. use File::Basename; #You can also use the LRR Internal API when fitting. use LANraragi::Model::Plugins; use LANraragi::Utils::Database qw(redis_encode redis_decode); use LANraragi::Utils::Logging qw(get_logger); #Meta-information about your plugin. sub plugin_info { return ( #Standard metadata name =\u003e \"Use foldername as tag\", type =\u003e \"metadata\", namespace =\u003e \"tagfolder\", author =\u003e \"Ftbom\", version =\u003e \"1.0\", description =\u003e \"Generate the tag from the folder's name.\", icon =\u003e \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAL1JREFUOI1jZMABpNbH/sclx8DAwPAscDEjNnEMQUIGETIYhUOqYdgMhTPINQzdUEZqGIZsKBM1DEIGTOiuexqwCKdidDl0vtT62P9kuZCJEWuKYWBgYGBgRHbh04BFDNIb4jAUbbSrZTARUkURg6lD10OUC/0PNaMYgs1Skgwk1jCSDCQWoBg46dYmhite0+D8pwGLCMY6uotRDOy8toZBkI2HIhcO/pxCm8KBUkOxFl/kGoq3gCXFYFxVAACeoU/8xSNybwAAAABJRU5ErkJggg==\", parameters =\u003e [ { type =\u003e \"string\", desc =\u003e \"The category of tag\" } ] #plugin设置 ); } #Mandatory function to be implemented by your plugin sub get_tags { shift; my $lrr_info = shift; # Global info hash my ($category) = @_; # Plugin parameters my $logger = get_logger( \"tagfolder\", \"plugins\" ); my $file = $lrr_info-\u003e{file_path}; #完整文件地址 my $tagstring; # lrr_info's file_path is taken straight from the filesystem, which might not be proper UTF-8. # Run a decode to make sure we can derive tags with the proper encoding. $file = redis_decode($file); # Get the filename from the file_path info field my ( $filename, $filepath, $suffix ) = fileparse( $file, qr/\\.[^.]*/ ); $_ = \"$filepath\"; #获取文件地址 if (/\\/([^\\/]+)\\/$/) { $tagstring=\"$category:$1\"; #上级目录作tag名 } $logger-\u003edebug( \"Sending the following tags to LRR: \" . $tagstring ); return ( tags =\u003e $tagstring ); } 1; ","date":"2023-01-03","objectID":"/lanraragi_plugins/:2:1","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi_plugins/#tagfolderpm"},{"categories":["技术笔记"],"content":"TopfolderCat.pm 参照Subfolders to Categories v.1.0 by Difegue \r\r使用说明： 点击Trigger Script运行脚本 Plugin Settings设置是否先删除已有的类型 文件内容： package LANraragi::Plugin::Scripts::TopfolderCat; use strict; use warnings; use File::Find; use File::Basename; use Data::Dumper; use LANraragi::Utils::Logging qw(get_logger); use LANraragi::Utils::Generic qw(is_archive); use LANraragi::Utils::Database qw(compute_id); use LANraragi::Model::Category; our $fatherdirname; #Meta-information about your plugin. sub plugin_info { return ( #Standard metadata name =\u003e \"Top Subfolders to Categories\", type =\u003e \"script\", namespace =\u003e \"Tfldr2cat\", author =\u003e \"Ftbom\", version =\u003e \"1.0\", icon =\u003e \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAuJJREFUOI3FlE1sVFUUx3/nvVdaSqd0sAmElDYopOWjsKiEnYkLowU2uMGw0ajBhS5oqAtwo3FTaIQNCz7CBldEE01M+AglJMACUyBQrI6iQ2groNNxpjPz5n3MnXddvOnrfACNK09yk/fuved3//933j3wf8Thw6O6q6tHd3X16FOnTusX7ZW7I7H0kuUrV6hCtmHxt7UnOXHiDInEJAAzM49kscMtw2xesWHfKOTGASNa+GnmHfYP7gSgr28TY2PnF4UBWAD88Tlk7kFVyuDbX0ew43vzU/6bnc+12vnqx4OrX//i4gIQXS2uJkZGvqRXD3Q/V9LKXdjmSxcmjq7ahi6vtRazMKAHGua8oolbsHDyFk7iF4r/3IOyGl9QKI1u+vo2kUhMsmZ3T8Pa5c+E5vYYzbFWWkQTW23R+XKc+9/+eKUB+MbBHZWqhpW9MGSjtdDes57OzRtZ2hFD4tshcEAVkHIeVIapse8wDPNQxbKBDuDhxHKODd5myZ44698dBTQgUbEkex0CFzJXIfDC58CDwCP3Z1ZtPpAaD4FWnJIv2Nkm+j85AroE/jRoHwI/SgoBbt27h+54DS3je0VEh7VtimOnm2mKxRcguhpUDXvGUDb9bd3fh14rCtNPWuh9/6s6RfWq6mEetG0le/cb5KPbpajKActwChaIVNR5ddAqeLkCmt9TLjCbzEVFtQDstENTW0c4M58cJbiNsPmxtBs7eQ03p87VANP3J+n94CjiPKj76N4z7M4f6IPKk35YAFMORUCzpRU3/VdoV82BytUm+jMQlEArlBJmEyncORdnroTypxCRt7YMp5IRUBVzv/cPnV0n+VshyH8MgYuycyjHJjPt4GbyONki5VIAItfQnBeTG62YD1458DTF8EJXscSw1lEu4s0m8TJ/k/o5iZuZIygHlb+ZHwzkUoC+2T+cuiNSd08/re1qMjFa25YM5D0xjVtGe8fUhg9/zfMf41+ZdKPYI8TqHgAAAABJRU5ErkJggg==\", description =\u003e \"Scan your Content Folder and automatically create Static Categories for each top subfolder.\", parameters =\u003e [ { type =\u003e \"bool\", desc =\u003e \"Delete all your static categories before creating the ones matching your subfolders\" } ] ); } # Mandatory function to be implemented by your script sub run_script { shift; my $lrr_info = shift; my ($delete_old_cats) = @_; my $logger = get_logger( \"Folder2Category\", \"plugins\" ); my $userdir = LANraragi::Model::Config-\u003eget_userdir; my %subfolders; my @created_categories; if ($delete_old_cats) { $logger-\u003einfo(\"Deleting all Static Categories before folder walking as instructed.\"); my @categories = LANraragi::Model::Category-\u003eget_category_list; for my $category (@categories) { if ( %{$category}{\"search\"} eq \"\" ) { my $cat_id = %{$category}{\"id\"}; $logger-\u003edebug(\"Deleting '$cat_id'\"); LANraragi::Model::Category::delete_category($cat_id); } } } # Walk through content folder and find all subfolders with files in them find( { wanted =\u003e sub { return if $File::Find::dir eq $userdir; # Direct children of the content dir are excluded if ( is_archive($_) ) { unless ( exists( $subfolders{$fatherdirname} ) ) { $subfolders{$fatherdirname} = []; # Create array in hash for this folder } push @{ $subfolders{$fatherdirname} }, $_; } else { $fatherdirname = basename($File::Find::dir); } }, no_chdir =\u003e 1, follow_fast =\u003e 1 }, $userdir ); $logger-\u003edebug( \"Find routine results: \" . Dumper %subfolders ); # For each subfolder with file, create a category bearing its name and containing all its files for my $folder ( keys %subfolders ) { my $catID = LANraragi::Model::Category::create_category( $folder, \"\", 0, \"\" ); push @created_categories, $catID; for my $file ( @{ $subfolders{$folder} } ) { my $id = compute_id($file) || next; LANraragi::Model::Category::add_to_category( $catID, $id ); } } #顶级目录名作分类名 return ( created_categories =\u003e \\@created_categories ); } 1; ","date":"2023-01-03","objectID":"/lanraragi_plugins/:2:2","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi_plugins/#topfoldercatpm"},{"categories":["技术笔记"],"content":"代码浅析简单分析一下这两个插件的代码，我并没有系统地学习过Perl语言，分析过程可能存在错误。 plugin_info函数返回插件的基本信息；TagFolder是元数据插件，主体内容是get_tags函数；TopfolderCat是脚本，主体内容是run_script函数。 plugin_info函数的parameters返回值定义了插件的设置项，例如： TagFolder定义插件的设置项是string类型，获取输入字符；TopfolderCat定义插件的设置项是bool类型，获取开关的状态。 在主体函数中可以通过@_获取插件的设置值。 ","date":"2023-01-03","objectID":"/lanraragi_plugins/:3:0","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi_plugins/#代码浅析"},{"categories":["技术笔记"],"content":"TagFolder.pm分析TagFolder参照Filename Parsing，对其中关键代码的运行过程进行分析。 首先获取全局信息和插件设置： my $lrr_info = shift; #全局信息 my ($category) = @_; #插件设置 全局信息中包括文件路径： my $file = $lrr_info-\u003e{file_path}; 然后从文件路径中分离出文件名和文件所在文件夹路径，我们需要的是文件夹路径： my ( $filename, $filepath, $suffix ) = fileparse( $file, qr/\\.[^.]*/ ); 从文件夹路径中获取文件夹名，得到tag字符串： $_ = \"$filepath\"; #$_是默认的参数变量 if (/\\/([^\\/]+)\\/$/) { $tagstring=\"$category:$1\"; #$1获取正则表达式匹配的第一项 } 最后输出tag信息： return ( tags =\u003e $tagstring ); ","date":"2023-01-03","objectID":"/lanraragi_plugins/:3:1","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi_plugins/#tagfolderpm分析"},{"categories":["技术笔记"],"content":"TopfolderCat.pm分析TopfolderCat.pm参照Subfolders to Categories，相较于参考文件改动较小，改动部分为： return if $File::Find::dir eq $userdir; # Direct children of the content dir are excluded if ( is_archive($_) ) { unless ( exists( $subfolders{$fatherdirname} ) ) { $subfolders{$fatherdirname} = []; # Create array in hash for this folder } push @{ $subfolders{$fatherdirname} }, $_; } else { $fatherdirname = basename($File::Find::dir); } 这里假设文件目录结构为： category1 --tag1 --mangafile1 --mangafile2 --tag2 --mangafile3 category2 --tag3 --mangafile4 首先排除漫画目录的直接子文件夹，即categroy1、categroy2等文件夹： return if $File::Find::dir eq $userdir; 对于其他的文件和文件夹，如果是文件夹，即tag1、tag2等文件夹，则将其父目录的名称赋值给fatherdirname。即将categroy1、categroy2等赋值给fatherdirname: else { $fatherdirname = basename($File::Find::dir); } 如果是文件，若其路径中存在fatherdirname，则将其添加到对应数组。例如：mangafile1、mangafile2、mangafile3文件被添加到category1对应的数组： if ( is_archive($_) ) { unless ( exists( $subfolders{$fatherdirname} ) ) { $subfolders{$fatherdirname} = []; # Create array in hash for this folder } push @{ $subfolders{$fatherdirname} }, $_; } 最后通过这些数组来创建类别，并将对应漫画添加到类别中： for my $folder ( keys %subfolders ) { my $catID = LANraragi::Model::Category::create_category( $folder, \"\", 0, \"\" ); push @created_categories, $catID; for my $file ( @{ $subfolders{$folder} } ) { my $id = compute_id($file) || next; LANraragi::Model::Category::add_to_category( $catID, $id ); } } ","date":"2023-01-03","objectID":"/lanraragi_plugins/:3:2","series":null,"tags":["LANraragi"],"title":"LANraragi插件小记","uri":"/lanraragi_plugins/#topfoldercatpm分析"},{"categories":["技术笔记"],"content":"\rLANraragi是开源的漫画管理服务器，开发者提供了多种安装方式供选择。本文介绍如何在Termux中安装LANraragi，实现对Android手机内的漫画进行管理。 ","date":"2023-01-03","objectID":"/lanraragi_in_termux/:0:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi_in_termux/#"},{"categories":["技术笔记"],"content":"安装Termux及Ubuntu发行版Termux是Android系统上的一个高级终端模拟器，可以运行很多Linux系统的软件，还可通过proot安装各种Linux系统发行版。推荐通过Github安装Termux软件。 警告\r\r第一次打开Termux若初始化失败，请使用代理\r\r 安装完成后，首先使Termux获取储存权限： termux-setup-storage 安装proot-distro： pkg install proot-distro 然后安装Ubuntu proot-distro install ubuntu 安装完成后，通过如下命令可进入Ubuntu proot-distro login ubuntu ","date":"2023-01-03","objectID":"/lanraragi_in_termux/:1:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi_in_termux/#安装termux及ubuntu发行版"},{"categories":["技术笔记"],"content":"安装LANraragi采用源码安装的方式安装LANraragi。 首先，进入Ubuntu并更新软件源： proot-distro login ubuntu apt update 首先安装LANraragi所需的依赖项： apt install git curl build-essential make gnupg pkg-config cpanminus redis-server libarchive-dev imagemagick webp libssl-dev zlib1g-dev perlmagick ghostscript 然后安装npm和nodejs： curl -sL install-node.vercel.app/lts | bash 安装redis： apt install redis 克隆Git仓库： git clone -b master http://github.com/Difegue/LANraragi /home/koyomi/lanraragi 打开目录并进行编译安装： cd /home/koyomi/lanraragi \u0026\u0026 npm run lanraragi-installer install-full 编译需要30-60分钟。 若需要对LANraragi进行更新： git clone -b master http://github.com/Difegue/LANraragi lanraragi cp -fr lanraragi /home/koyomi/ npm run lanraragi-installer install-full ","date":"2023-01-03","objectID":"/lanraragi_in_termux/:2:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi_in_termux/#安装lanraragi"},{"categories":["技术笔记"],"content":"运行LANraragi通过以下命令运行LANraragi： redis-server /etc/redis/redis.conf cd /home/koyomi/lanraragi \u0026\u0026 npm start ","date":"2023-01-03","objectID":"/lanraragi_in_termux/:3:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi_in_termux/#运行lanraragi"},{"categories":["技术笔记"],"content":"设置档案位置若已通过以下命令使Termux获取储存权限： termux-setup-storage 则在Ubuntu的/sdcard目录下可以看到Android系统的文件，在LANraragi的设置中设置成对应的漫画目录即可。 ","date":"2023-01-03","objectID":"/lanraragi_in_termux/:4:0","series":null,"tags":["LANraragi","Termux"],"title":"在Termux中安装LANraragi","uri":"/lanraragi_in_termux/#设置档案位置"},{"categories":["技术笔记"],"content":"\rJulia是一种高级通用动态编程语言，可以用于数值分析和科学计算等。 Julia语言没有内建的作图能力，作图需要通过安装扩展包来实现，常用的作图包有Gadfly、Plots和PyPlot。 本文介绍如何在Julia脚本文件中使用Plots进行绘图并正常显示绘图结果。 Julia和Plots版本\r\rJulia v1.7.2 Plots v1.25.11 \r\r ","date":"2022-02-25","objectID":"/julia_plot_in_file/:0:0","series":null,"tags":["Julia"],"title":"Julia脚本文件中使用Plots绘图","uri":"/julia_plot_in_file/#"},{"categories":["技术笔记"],"content":"在REPL中运行脚本文件在REPL中，Julia会对每个变量自动调用display函数进行显示。在REPL中直接使用plot函数可以正常显示绘图的结果。 本文的主要目的是使用脚本文件进行绘图，在REPL中运行脚本文件的命令为： include(\"path/to/script.jl\") ","date":"2022-02-25","objectID":"/julia_plot_in_file/:1:0","series":null,"tags":["Julia"],"title":"Julia脚本文件中使用Plots绘图","uri":"/julia_plot_in_file/#在repl中运行脚本文件"},{"categories":["技术笔记"],"content":"使用julia path/to/script.jl运行脚本文件如果不在REPL中运行脚本文件时，Julia不会自动调用display函数。 为了显示绘图结果，需要在代码中调用display函数。 但是，使用julia path/to/script.jl运行脚本文件时，程序会在文件中所有语句执行完毕后自动退出，这样就看不到绘图结果。 为了防止Julia执行完所有语句后退出，可以在脚本文件的末尾使用readline函数。 这种运行方式下需将代码做如下更改： plot(x, y) 改为 display(plot(x, y)) ... readline() 然后终端运行julia path/to/script.jl即可得到绘图结果。 ","date":"2022-02-25","objectID":"/julia_plot_in_file/:2:0","series":null,"tags":["Julia"],"title":"Julia脚本文件中使用Plots绘图","uri":"/julia_plot_in_file/#使用julia-pathtoscriptjl运行脚本文件"},{"categories":["技术笔记"],"content":"使用VScode插件Julia运行脚本文件使用Julia插件运行代码时，会自动将绘图结果显示在一个新的标签栏中，于是直接使用plot函数就可以得到绘图结果。 需要注意的是：在VScode中不可使用Code Runner插件来运行脚本文件，而要使用Julia插件来运行脚本文件。 ","date":"2022-02-25","objectID":"/julia_plot_in_file/:3:0","series":null,"tags":["Julia"],"title":"Julia脚本文件中使用Plots绘图","uri":"/julia_plot_in_file/#使用vscode插件julia运行脚本文件"}]